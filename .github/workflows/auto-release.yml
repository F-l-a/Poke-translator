name: Auto Release Translation

on:
  workflow_dispatch:
    inputs:
      is_automatic:
        description: 'Set to true for automatic runs (internal use)'
        required: false
        default: false
        type: boolean
      mod_version:
        description: 'Manual mod version override (e.g., 1.0.1a). Leave empty for auto-calc.'
        required: false
        default: ''
        type: string
      force_release:
        description: 'Force release even if no recent update is found (manual runs only)'
        required: false
        default: false
        type: boolean

permissions:
  contents: write

jobs:
  auto-release:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' }}
    
    steps:
    - name: Checkout repository with submodules
      uses: actions/checkout@v4
      with:
        submodules: recursive
        token: ${{ secrets.PAT_PUSH || secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Git user
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

    - name: Check context and submodule status
      id: check_context
      run: |
        echo "is_automatic_run=${{ inputs.is_automatic }}" >> $GITHUB_OUTPUT
        
        if [ "${{ inputs.is_automatic }}" = "false" ]; then
          if [ "${{ inputs.force_release }}" = "true" ]; then
            echo "Proceeding due to force_release=true"
            echo "proceed=true" >> $GITHUB_OUTPUT
          else
            echo "Proceeding with manual run"
            echo "proceed=true" >> $GITHUB_OUTPUT
          fi
        else
          echo "Proceeding with automatic run"
          echo "proceed=true" >> $GITHUB_OUTPUT
        fi
        
        # Estrai l'hash corto del sottomodulo (non piÃ¹ la tag)
        cd input/SupersStrings
        SUBMODULE_HASH=$(git rev-parse --short HEAD)
        cd ../..
        echo "submodule_hash=$SUBMODULE_HASH" >> $GITHUB_OUTPUT
        echo "Detected SupersStrings commit: $SUBMODULE_HASH"

    - name: Calculate new mod version
      if: steps.check_context.outputs.proceed == 'true'
      id: calc_version
      run: |
        SUBMODULE_HASH="${{ steps.check_context.outputs.submodule_hash }}"
        IS_AUTOMATIC="${{ inputs.is_automatic }}"
        MOD_VERSION=""

        # 1. Override manuale
        if [ "$IS_AUTOMATIC" = "false" ] && [ -n "${{ inputs.mod_version }}" ]; then
          MOD_VERSION="${{ inputs.mod_version }}"
          echo "Rule: Manual override. Using provided version: $MOD_VERSION"
        else
          # 2. Ottieni l'ultima tag globale della mod
          LATEST_OVERALL_TAG=$(git tag -l "*-mod_*" | sort -V | tail -1)
          
          if [ -z "$LATEST_OVERALL_TAG" ]; then
            MOD_VERSION="1.0.0"
            echo "Rule: First ever release. Starting with $MOD_VERSION."
          else
            LATEST_OVERALL_SUBMODULE_HASH=$(echo "$LATEST_OVERALL_TAG" | sed -n 's/-mod_.*//p')
            LATEST_OVERALL_MOD_VERSION=$(echo "$LATEST_OVERALL_TAG" | sed -n 's/.*-mod_//p')
            BASE_VERSION=$(echo "$LATEST_OVERALL_MOD_VERSION" | sed 's/[a-z]*$//')
            
            # 3. Confronta gli hash per capire cosa Ã¨ cambiato
            if [ "$SUBMODULE_HASH" != "$LATEST_OVERALL_SUBMODULE_HASH" ]; then
              # Scenario 1: Il sottomodulo Ã¨ stato aggiornato. Incrementiamo la patch (es. 1.0.0 -> 1.0.1)
              MAJOR_MINOR=$(echo "$BASE_VERSION" | cut -d. -f1-2)
              PATCH=$(echo "$BASE_VERSION" | cut -d. -f3)
              MOD_VERSION="${MAJOR_MINOR}.$((PATCH + 1))"
              echo "Rule: Submodule updated ($LATEST_OVERALL_SUBMODULE_HASH -> $SUBMODULE_HASH). Bumping version to: $MOD_VERSION."
            else
              # Scenario 2: Sottomodulo identico. Incrementiamo la lettera (es. 1.0.1 -> 1.0.1a)
              if [[ "$LATEST_OVERALL_MOD_VERSION" =~ [a-z]$ ]]; then
                LAST_CHAR="${LATEST_OVERALL_MOD_VERSION: -1}"
                NEXT_CHAR=$(printf "\\$(printf '%03o' "$(( $(printf '%d' "'$LAST_CHAR") + 1 ))")")
                MOD_VERSION="${BASE_VERSION}${NEXT_CHAR}"
              else
                MOD_VERSION="${BASE_VERSION}a"
              fi
              echo "Rule: Same submodule. Incrementing revision letter to $MOD_VERSION."
            fi
          fi
        fi

        # --- Final Step: Tag Conflict Resolution ---
        while true; do
          PROPOSED_TAG="${SUBMODULE_HASH}-mod_${MOD_VERSION}"
          if git rev-parse "$PROPOSED_TAG" >/dev/null 2>&1; then
            echo "Conflict: Tag $PROPOSED_TAG already exists. Incrementing letter."
            if [[ "$MOD_VERSION" =~ [a-z]$ ]]; then
              NEXT_CHAR=$(printf "\\$(printf '%03o' "$(( $(printf '%d' "'${MOD_VERSION: -1}") + 1 ))")")
              MOD_VERSION="${MOD_VERSION%?}${NEXT_CHAR}"
            else
              MOD_VERSION="${MOD_VERSION}a"
            fi
          else
            echo "Tag $PROPOSED_TAG is available."
            break
          fi
        done

        echo "final_mod_version=$MOD_VERSION" >> $GITHUB_OUTPUT
        echo "final_tag=$PROPOSED_TAG" >> $GITHUB_OUTPUT
        echo "Final version tag will be: $PROPOSED_TAG"

    - name: Set up Python
      if: steps.check_context.outputs.proceed == 'true'
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      if: steps.check_context.outputs.proceed == 'true'
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run automatic translation
      if: steps.check_context.outputs.proceed == 'true'
      id: translate
      run: |
        MOD_VERSION_NUM="${{ steps.calc_version.outputs.final_mod_version }}"
        python3 automated_translation.py --lang_code it --mod_version "$MOD_VERSION_NUM"

    - name: Read zip name and create release package
      if: steps.check_context.outputs.proceed == 'true'
      id: create_package
      run: |
        ZIP_NAME=$(cat output/IT/zip_name.txt)
        echo "zip_name=$ZIP_NAME" >> $GITHUB_OUTPUT
        cd output/IT
        zip -r "../../${ZIP_NAME}.zip" .
        cd ../..
        echo "Created release package: ${ZIP_NAME}.zip"

    - name: Create GitHub Release
      if: steps.check_context.outputs.proceed == 'true'
      id: create_release
      run: |
        FINAL_TAG="${{ steps.calc_version.outputs.final_tag }}"
        SUBMODULE_HASH="${{ steps.check_context.outputs.submodule_hash }}"
        ZIP_NAME="${{ steps.create_package.outputs.zip_name }}"
        
        if [ "${{ inputs.is_automatic }}" = "true" ]; then
          RELEASE_TITLE="SupersStoryStrings ${FINAL_TAG} - AUTOMATIC RELEASE"
        else
          RELEASE_TITLE="SupersStoryStrings ${FINAL_TAG}"
        fi

        # Changelog snello basato sul commit
        FINAL_BODY=$(cat <<EOF
        This mod translates the following into Italian: Buttons, Items, Natures (Multi-language), Abilities (Multi-language), and Locations (Multi-language).

        > [!NOTE]  
        > This release is intended for use with the PokeMMO client set to English.  
        > If you want to use the strings with a different client language, you will need to edit \`lang="en"\` and/or \`lang_full="English"\` at the beginning of each \`.xml\` file inside the \`/strings\` folder in the ZIP archive, so they match your client's language settings.

        ***

        ## Changelog

        **Version ${FINAL_TAG}:**
        - Built against SupersStrings commit: \`${SUBMODULE_HASH}\`
        EOF
        )

        gh release create "$FINAL_TAG" \
          --title "$RELEASE_TITLE" \
          --notes "$FINAL_BODY" \
          "${ZIP_NAME}.zip"
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Summary
      if: steps.check_context.outputs.proceed == 'true'
      run: |
        if [ "${{ inputs.is_automatic }}" = "true" ]; then
          EXEC_TYPE="ðŸ¤– Automatic Release"
        else
          EXEC_TYPE="ðŸ”§ Manual Release"
        fi
        
        echo "## ðŸš€ Release Completed!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Execution Type**: $EXEC_TYPE" >> $GITHUB_STEP_SUMMARY
        echo "**New Release Tag**: \`${{ steps.calc_version.outputs.final_tag }}\`" >> $GITHUB_STEP_SUMMARY
        echo "**SupersStrings Hash**: \`${{ steps.check_context.outputs.submodule_hash }}\`" >> $GITHUB_STEP_SUMMARY
        echo "**Mod File**: \`${{ steps.create_package.outputs.zip_name }}.zip\`" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ inputs.is_automatic }}" = "false" ] && [ -n "${{ inputs.mod_version }}" ]; then
          echo "**Mod Version Override**: \`${{ inputs.mod_version }}\`" >> $GITHUB_STEP_SUMMARY
        fi
